#!/usr/bin/env python
import  os
import  sys
import  string
import  getopt
import  argparse
import  csv
import  stack
from    _common import systemMisc       as misc
from    _common import crun


class ZRS5():
    '''
    This is the main 'controller' class for the dyslexia curvature analysis.

    There are several 'modules' that are executed in pipeline-order. The
    actual modules to run can be specified before running the pipeline.
    
    '''

    # 
    # Class member variables -- if declared here are shared
    # across all instances of this class
    #
    _dictErr = {
        'subjectSpecFail'   : {
            'action'        : 'examining command line arguments, ',
            'error'         : 'it seems that no subjects were specified.',
            'exitCode'      : 10},
        'subjectDirnotExist': {
            'action'        : 'examining the <subjectDirectories>, ',
            'error'         : 'the directory does not exist.',
            'exitCode'      : 13},
        'Load'              : {
            'action'        : 'attempting to pickle load object, ',
            'error'         : 'a PickleError occured.',
            'exitCode'      : 14}
    }

    def error_exit( self,
                            astr_key,
                            ab_exitToOs=1
                            ):
        print "\tSorry, some error seems to have occurred in <%s>" \
                    % ( self.__name__)
        print "\tWhile %s"           % ZRS5._dictErr[astr_key]['action']
        print "\t%s"                 % ZRS5._dictErr[astr_key]['error']
        print ""
        if ab_exitToOs:
            print "Returning to system with error code %d" % \
                                        ZRS5._dictErr[astr_key]['exitCode']
            sys.exit( ZRS5._dictErr[astr_key]['exitCode'] )
        return ZRS5._dictErr[astr_key]['exitCode']

    def fatal( self, astr_key, astr_extraMsg="" ):
        print synopsis(True)
        if len( astr_extraMsg ): print astr_extraMsg
        self.error_exit( astr_key )

    def warn( self, astr_key, astr_extraMsg="" ):
        b_exitToOS = 0
        if len( astr_extraMsg ): print astr_extraMsg
        self.error_exit( astr_key, b_exitToOS )  

    def vprintf(self, alevel, format, *args):
        '''
        A verbosity-aware print.
        
        '''
        if self._verbosity and self._verbosity < alevel:
            sys.stdout.write(format % args)
        
    def __init__(self, **kwargs):
        '''
        Basic constructor. Checks on named input args, checks that files
        exist and creates directories.

        '''
        self.__name__                   = 'zrs'
        self._verbosity                 = 0

        self._l_subject                  = []
        
        self._str_subjectDir            = ''
        self._b_strictCheck             = False
        self._b_query                   = False
        self._b_debugMode               = False
        self._duplicateCount            = 0
        self._entryCreatedCount         = 0
        self._entryReadCount            = 0
        self._stack                     = stack.Stack()
        
        for key, value in kwargs.iteritems():
            if key == 'subjectList':    self._l_subject         = value
            if key == 'query':          self._b_query           = value


    def initialize(self):
        '''
        This method provides some "post-constructor" initialization. It is
        typically called after the constructor and after other class flags
        have been set (or reset).
        
        '''
        for str_subj in self._l_subject:
            self.vprintf(9, '%30s', ('Checking on subjectDir <%s>' % str_subj))
            if os.path.isdir(str_subj):
                self.vprintf(9, '%30s\n', '[ ok ]')

                
    def run(self):
        '''
        The main 'engine' of the class.

        '''

    def lobes_annot(self):
        '''
        Run the lobar annotation stage.
        
        '''
        shell = crun()
        
        
    def stages(self, *args):
        if len(args):
            self._stages                = args[0]
        else:
            return self._stages

            
    def verbosity(self, *args):
        if len(args):
            self._verbosity             = args[0] 
        else:
            return self._verbosity

            
    def stack(self, *args):
        if len(args):
            for e in args:
                self._stack.push(e)
        else:
            return self._stack

            
    def entriesRead(self, *args):
        if len(args):
            self._entryReadCount        = args[0] 
        else:
            return self._entryReadCount

            
def synopsis(ab_shortOnly = False):
  scriptName = os.path.basename(sys.argv[0])
  shortSynopsis =  '''
  SYNOPSIS
  
        %s                                            \\
                        [--stages <stages>]             \\
                        [--query]                       \\
                        [-v|--verbosity <verboseLevel>] \\
                        <Subj1> <Subj2> ... <SubjN>
  ''' % scriptName
  
  description =  '''
  DESCRIPTION
  
        `%s' is a meta-controller for setting up and analyzing a set of Dyslexia
        experiments.
        
  ARGS
  
        
  EXAMPLES

          
  ''' % (scriptName)
  if ab_shortOnly:
      return shortSynopsis
  else:
      return shortSynopsis + description


#
# entry point
#
if __name__ == "__main__":

    # always show the help if no arguments were specified
    if len( sys.argv ) == 1:
        print synopsis()
        sys.exit( 1 )

    l_subj      = []
    b_query     = False
    verbosity   = 0

    parser = argparse.ArgumentParser(description = 'Dyslexia Curvature Analysis')
    
    parser.add_argument('l_subj',
                        metavar='SUBJECT', nargs='+',
                        help='SubjectIDs to process')
    parser.add_argument('--verbosity', '-v',
                        dest='verbosity', 
                        action='store_const',
                        const=0, default=0,
                        help='verbosity level')
    parser.add_argument('--stages', '-s',
                        dest='stages',
                        action='store_const',
                        const=1, default=1,
                        help='analysis stages')

    args = parser.parse_args()

    parser = ZRS5(subjectList = args.l_subj)
    parser.verbosity(verbosity)
    parser.stages(stages)
    parser.initialize()
    parser.run()
  
