#!/bin/bash
#
# dcm_coreg.bash
#
# Copyright 2008 Rudolph Pienaar
# Massachusetts General Hospital
#
# SPDX-License-Identifier: MIT
#

# "include" the set of common script functions
source ~/arch/scripts/common.bash

declare -i Gi_verbose=0
declare -i Gb_useExpertOptions=0
declare -i Gb_useOverrideOut=0
declare -i Gb_forceStage=1
declare -i Gb_useMatrix=0

G_LOGDIR="-x"
G_OUTDIR="/chb/osx1927/1/users/dicom/postproc"
G_OUTRUNDIR="-x"
G_OUTPREFIX="-x"
G_DICOMINPUTDIR="-x"
G_DICOMINPUTFILE="-x"
G_DICOMINPUTREF="-x"
G_INPUTMAT="-x"
G_FLIRTOPT="-x"

G_INPUTNAME=""
G_REFNAME=""

G_STAGES="12"

G_SYNOPSIS="

 NAME

	dcm_coreg.bash

 SYNOPSIS

	dcm_coreg.bash          -D <dicomInputDir>                      \\
                                -d <dicomInputFile>                     \\
                                -r <dicomInputReferenceFile>            \\
                                -o <outputRunDir>                       \\
                                [-I <inputFileTag>]                     \\
                                [-R <referenceFileTag>]                 \\
                                [-E]                                    \\
                                [-m <inputMatrix>]                      \\
                                [-v <verbosity>]  			\\
				[-O <experimentTopDir>]			\\
                                [-p <outputPrefix>]

 DESCRIPTION

	'dcm_coreg.bash' is a thin wrapper about a 'flirt' registration
        process that co-registers an input volume to a reference volume.
        These volumes are specified as DICOM format files.

        The script (after checking for some simple failure conditions)
        converts the relevant volumes to analyze format, and then calls
        'flirt'. Additional options to 'flirt' can be specified in the
        <flirtOptsFile>, whose contents are blindly appended to the
        'flirt' command line.

 ARGUMENTS

	-v <level> (optional)
	Verbosity level.

        -D <dicomInputDir>
        The directory containing DICOM files for a particular study.

        -d <dicomInputFile> 
        A file in <dicomInputDir> specifying the volume to use as 'input'
        for registration. All files in this series are automatically
        converted to a single Analyze format volume.

        -I <inputFileTag>
        If specified, call the input reference <inputFileTag>.

        -r <dicomInputReferenceFile>
        A file in <dicomInputDir> specifying the volume to use as 'reference'
        for registration. All files in this series are automatically
        converted to a single Analyze format volume.

        -R <referenceFileTag>
        If specified, call the reference file <refFileTag>.

        -O <experimentTopDir> (optional) (Default: $G_OUTDIR)
        The root directory node that contains the outputs of a particular
        registration run. Each run is stored in its own directory.

        -o <outputRunDir> 
        A descriptive name prefixed to each volume generated by a registration
        run.

        -E (Optional)
        Use 'expert' option files. For each processing run, if this flag
        is indicated, the output directory will be scanned for any files
        named <STAGEPROC>.opt -- which if found will be parsed and their
        contents appended *blindly* to the <STAGECMD> for that stage.

        -p <outputPrefix> (Optional)
        If specified, prefix all generated output files with <outputPrefix>.


 PRECONDITIONS
	
	o nde

 POSTCONDITIONS

	o Output registered volumes (and matrices) are stored in:

              <experimentTopDir>/<outputRunDir>

          with the output volume and output matrix files: 
              <outputPrefix>-registered.[{img}{mat}] 

 HISTORY

	12 September 2008
	o Initial design and coding.

"

###\\\
# Globals are in capital letters. Immutable globals are prefixed by 'G'.
###///
G_SELF=`basename $0`
G_PID=$$

# Actions
A_fileCheck="checking for a required file dependency"
A_noDicomDir="checking on input DICOM directory"
A_noOutRunDir="checking on output run directory"
A_noDicomFile="checking on input DICOM file"
A_noDicomRefFile="checking on input DICOM reference file"
A_noMatrixFile="checking on input matrix reference file"
A_noDicomDirArg="checking on -d <dicomInputDir> argument"
A_noExpDir="checking on the output root directory"
A_metaLog="checking the meta log file"
A_runflirt="executing 'flirt'"
A_noFlirt="checking for the 'flirt' binary"
A_exitFlirt="running the 'flirt' process"
A_dependencyStage="checking for a required dependency from an earlier stage"
A_stageRun="running a stage in the processing pipeline"

# Error messages
EM_fileCheck="it seems that a dependency is missing."
EM_noDicomDir="I couldn't access the input DICOM dir. Does it exist?"
EM_noOutRunDir="I couldn't access the output run dir. Does it exist?"
EM_noDicomFile="I couldn't find the input DICOM file. Does it exist?"
EM_noDicomRefFile="I couldn't find an input DICOM reference file. Does it exist?"
EM_noMatrixFile="I couldn't find an input matrix reference file. Does it exist?"
EM_noDicomDirArg="it seems as though you didn't specify a -D <dicomInputDir>."
EM_noExpDir="I couldn't find the <expDir>."
EM_metaLog="it seems as though this stage has already run.\n\tYou can force execution with a '-F'"
EM_runflirt="the process died unexpectedly."
EM_noFlirt="I couldn't find 'flirt' anywhere on your path."
EM_exitFlirt="it seems as though an unexpected exit has occurred."
EM_dependencyStage="it seems that a stage dependency is missing."
EM_stageRun="I encountered an error processing this stage."

# Error codes
EC_fileCheck=1
EC_dependencyStage=2
EC_stageRun=30
EC_noDicomDir=50
EC_noOutRunDir=54
EC_noDicomDirArg=51
EC_noDicomFile=52
EC_noDicomRefFile=53
EC_noMatrixFile=54
EC_noExpDir=23
EC_metaLog=80
EC_runflirt=90
EC_noFlirt=40
EC_exitFlirt=41

# Defaults
D_whatever=

###\\\
# Function definitions
###///


###\\\
# Process command options
###///

while getopts D:d:I:v:E:m:o:r:R:O:p: option ; do 
	case "$option"
	in
                D)      G_DICOMINPUTDIR=$OPTARG         ;;
                d)      Gb_useDICOMFile=1               
                        G_DICOMINPUTFILE=$OPTARG        ;;
                I)      G_INPUTNAME=$OPTARG             ;;
                v)      let Gi_verbose=$OPTARG          ;;
                E)      Gb_useExpertOptions=1           ;;
                m)      G_INPUTMAT=$OPTARG
                        Gb_useMatrix=1                  ;;
		O)      G_OUTDIR=$OPTARG                ;;
                r)      G_DICOMINPUTREF=$OPTARG         ;;
                R)      G_REFNAME=$OPTARG               ;;
		o)      Gb_useOverrideOut=1
                        G_OUTRUNDIR="$OPTARG"           ;;
                p)      G_OUTPREFIX="$OPTARG"           ;;
		\?)     synopsis_show 
                        exit 0;;
	esac
done

verbosity_check
topDir=$(pwd)

cprint  "hostname"      "[ $(hostname) ]"

## Check on script preconditions
REQUIREDFILES="common.bash flirt mri_convert dcm_mkIndx.bash"
for file in $REQUIREDFILES ; do
        printf "%40s"   "Checking for $file"
        file_checkOnPath $file || fatal fileCheck
done

## Check on input directory and files
statusPrint     "Checking -D <dicomInputDir>"
if [[ "$G_DICOMINPUTDIR" == "-x" ]] ; then fatal noDicomDirArg ; fi
ret_check $?
statusPrint     "Checking on <dicomInputDir>"
dirExist_check $G_DICOMINPUTDIR || fatal noDicomDir
cd $G_DICOMINPUTDIR >/dev/null
G_DICOMINPUTDIR=$(pwd)
cd $topDir

cd ${G_DICOMINPUTDIR}
statusPrint     "Scanning <dicomInputDir>"
ret_check $?
SCANTABLE=$(dcm_mkIndx.bash -t '_' |tr '(' '_' | tr ')' '_')
statusPrint     "Checking input volume"
DICOMINPUT=${G_DICOMINPUTDIR}/${G_DICOMINPUTFILE}
fileExist_check $DICOMINPUT || fatal noDicomFile
INPUTSCAN=$(echo "$SCANTABLE" | grep $G_DICOMINPUTFILE | awk '{print $3}')
if (( !${#INPUTSCAN} ));        then INPUTSCAN=$G_DICOMINPUTFILE;       fi
if (( ${#G_INPUTNAME} ));       then INPUTSCAN=$G_INPUTNAME;            fi
cprint "Input scan"     "[ $INPUTSCAN ]"

statusPrint     "Checking reference volume"
DICOMREFFILE=${G_DICOMINPUTDIR}/${G_DICOMINPUTREF}
fileExist_check $DICOMREFFILE || fatal noDicomRefFile
REFSCAN=$(echo "$SCANTABLE" | grep $G_DICOMINPUTREF | awk '{print $3}')
if (( !${#REFSCAN} ));          then REFSCAN=$G_DICOMINPUTREF;          fi
if (( ${#G_REFNAME} ));         then REFSCAN=$G_REFNAME;                fi

cprint "Reference scan" "[ $REFSCAN ]"

if [[ $G_OUTPREFIX == "-x" ]] ; then
  G_OUTPREFIX="$INPUTSCAN-To-$REFSCAN"
fi

statusPrint     "Checking on <outputRunDir>"
if (( !Gb_useOverrideOut )) ; then
  MRID=$(echo "$SCANTABLE" | grep ID | awk '{print $3}')
  G_OUTRUNDIR=${MRID}-$G_OUTPREFIX
fi
dirExist_check ${G_OUTDIR}/$G_OUTRUNDIR "not found - creating"  \
              || mkdir ${G_OUTDIR}/$G_OUTRUNDIR                 \
              || fatal noOutRunDir
cd ${G_OUTDIR}/$G_OUTRUNDIR >/dev/null
OUTDIR=$(pwd)
cd $topDir

if (( Gb_useMatrix )) ; then
  statusPrint     "Checking on <inputMatrix> file"
  fileExist_check $G_INPUTMAT || fatal noMatrixFile
fi

## Check which stages to process
statusPrint     "Checking which stages to process"
barr_stage=([0]=0 [1]=0 [2]=0 [3]=0 [4]=0 [5]=0)
for i in $(seq 1 2) ; do
        b_test=$(expr index $G_STAGES "$i")
        if (( b_test )) ; then b_flag="1" ; else b_flag="0" ; fi
        barr_stage[$i]=$b_flag
done
ret_check $?

G_LOGDIR=$OUTDIR
STAMPLOG=${G_LOGDIR}/${G_SELF}.log
stage_stamp "Init | ($(pwd)) $G_SELF $*" $STAMPLOG

STAGENUM=1
STAGEPROC="mri_convert"
ANALYZEIN="${OUTDIR}/${G_OUTPREFIX}-input.img"
ANALYZEREF="${OUTDIR}/${G_OUTPREFIX}-ref.img"
if (( ${barr_stage[1]} )) ; then
    statusPrint \
        "$(date) | Processing STAGE 1 - Converting to Analyze... | START" "\n"
    STAGE=${STAGENUM}-${STAGEPROC}
    statusPrint "Converting input volume"       "\n"
    STAGECMD="$STAGEPROC                                                \
              $DICOMINPUT                                               \
              $ANALYZEIN"
    stage_run   "$STAGE" "$STAGECMD"                                    \
                "${OUTDIR}/${STAGEPROC}.std"                            \
                "${OUTDIR}/${STAGEPROC}.err"                            \
                "SILENT"                                                \
                || fatal stageRun
    statusPrint "Converting reference volume"   "\n"
    STAGECMD="$STAGEPROC                                                \
              $DICOMREFFILE                                             \
              $ANALYZEREF"
    stage_run   "$STAGE" "$STAGECMD"                                    \
                "${OUTDIR}/${STAGEPROC}.std"                            \
                "${OUTDIR}/${STAGEPROC}.err"                            \
                "SILENT"                                                \
                || fatal stageRun
    statusPrint \
        "$(date) | Processing STAGE 1 - Converting to Analyze... | END" "\n"
fi
STAGE1OUT=$ANALYZEIN

STAGE2IN=$STAGE1OUT
STAGENUM=2
STAGEPROC=flirt
STAGE=2-$STAGE2PROC
STAGE2OUTBASE="${G_OUTDIR}/${G_OUTRUNDIR}/${G_OUTPREFIX}-registered"
if (( ${barr_stage[2]} )) ; then
    statusPrint "$(date) | Processing STAGE 2 - coregistration | START" "\n"
    statusPrint "Checking previous stage dependencies"
    fileExist_check     $ANALYZEIN      || fatal dependencyStage
    fileExist_check     $ANALYZEREF     || fatal dependencyStage
    INMATRIX=""
    OUTMATRIX="-omat $STAGE2OUTBASE.mat"
    if (( Gb_useMatrix )) ; then
      MATRIX="-applyxfm -init $G_INPUTMAT"
      OUTMATRIX=""
    fi
    EXOPTS=$(eval expertOpts_parse $STAGEPROC)
    STAGE=${STAGENUM}-${STAGEPROC}
    STAGECMD="$STAGEPROC                                        \
                -in     $ANALYZEIN                              \
                -ref    $ANALYZEREF                             \
                -out    $STAGE2OUTBASE.img                      \
                $INMATRIX                                       \
                $OUTMATRIX                                      \
                $EXOPTS"
    stage_run "$STAGE"  "$STAGECMD"                             \
              "${OUTDIR}/${STAGEPROC}.std"                      \
              "${OUTDIR}/${STAGEPROC}.err"                      \
              "SILENT"                                          \
              || fatal stageRun

    statusPrint "$(date) | Processing STAGE 2 - coregistration | END" "\n"
fi

verbosity_check
shut_down 0
